% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/loo.R
\name{loo}
\alias{loo}
\alias{loo.array}
\alias{loo.matrix}
\alias{loo.function}
\title{Leave-one-out cross-validation (LOO)}
\usage{
loo(x, ...)

\method{loo}{array}(x, ..., cores = getOption("loo.cores", 1), wtrunc = 3/4)

\method{loo}{matrix}(x, ..., chain_id, cores = getOption("loo.cores", 1),
  wtrunc = 3/4)

\method{loo}{function}(x, ..., chain_id, draws = NULL, data = NULL,
  cores = getOption("loo.cores", 1), wtrunc = 3/4)
}
\arguments{
\item{x}{A log-likelihood array, matrix, or function. See the \strong{Methods
(by class)} section below for a detailed description of how to specify the
inputs for each method.}

\item{...}{Arguments passed on to the various methods.}

\item{cores}{The number of cores to use for parallelization. The default for
an entire R session can be set with \code{options(loo.cores = NUMBER)}. As
of version \code{2.0.0} the \strong{default is now 1 core}, but we
recommend using as many (or close to as many) cores as possible.}

\item{wtrunc}{For truncating very large weights to \code{S^wtrunc}, where
\eqn{S} is the size of the posterior sample. The default and recommended
value is \code{3/4}. To turn off truncation set \code{wtrunc=0}.}

\item{chain_id}{A vector of length \code{NROW(x)} containing MCMC chain
indexes for each each row of \code{x} (if a matrix) or each value in
\code{x} (if a vector). No \code{chain_id} is needed if \code{x} is a 3-D
array. If there are \code{C} chains then valid chain indexes are values
in \code{1:C}.}

\item{draws, data}{For the function method only. See the \strong{Methods (by
class)} section below for details on these arguments.}
}
\value{
A named list with class \code{c("psis_loo", "loo")} and components:
\describe{
 \item{\code{estimates}}{
  A matrix with two columns (\code{"Estimate"}, \code{"SE"}) and three rows
  (\code{"elpd_loo"}, \code{"p_loo"}, \code{"looic"}). This contains point
  estimates and standard errors of the expected log pointwise predictive
  density (\code{elpd_loo}), the effective number of parameters
  (\code{p_loo}) and the LOO information criterion \code{looic} (which is
  just \code{-2 * elpd_loo}, i.e., converted to deviance scale).
 }
 \item{\code{pointwise}}{
  A matrix with three columns (and number of rows equal to the number of
  observations) containing the pointwise contributions of each of the above
  measures (\code{elpd_loo}, \code{p_loo}, \code{looic}).
 }
 \item{\code{diagnostics}}{
 A named list containing two vectors:
  \itemize{
   \item \code{pareto_k}: Estimates of the shape parameter \eqn{k} of the
   generaelized Pareto fit to the importance ratios for each leave-one-out
   distribution. See the \code{\link{pareto-k-diagnostic}} page for details.
   \item \code{n_eff}: PSIS effective sample size estimates.
  }
 }
}
}
\description{
Efficient approximate leave-one-out cross-validation for Bayesian models. See
\link{loo-package} and Vehtari, Gelman, and Gabry (2016, 2017) for
background.
}
\section{Methods (by class)}{
\itemize{
\item \code{array}: An \eqn{I} by \eqn{C} by \eqn{N} array, where \eqn{I}
is the number of MCMC iterations per chain, \eqn{C} is the number of
chains, and \eqn{N} is the number of data points. For example, the object
returned by \code{\link{extract_log_lik}(stanfit, merge_chains = FALSE)}.

\item \code{matrix}: An \eqn{S} by \eqn{N} matrix, where \eqn{S} is the size
of the posterior sample (with all chains merged) and \eqn{N} is the number
of data points. For example, the object returned by
\code{\link{extract_log_lik}(stanfit, merge_chains = TRUE)}.

\item \code{function}: A function \code{f} that takes arguments \code{data_i} and \code{draws} and
  returns a vector containing the log-likelihood for a single observation
  \code{i} evaluated at each posterior draw. The function should be written
  such that, for each observation \code{i} in \code{1:N}, evaluating
  \code{f(data_i = data[i,, drop=FALSE], draws = draws)} results in a vector
  of length \code{S} (size of posterior sample).

 If using the function method then the arguments \code{data}
 and \code{draws} must also be specified in the call to \code{loo}:
 \itemize{
   \item \code{data}: An object containing data (e.g. observed outcome and
   predictors) needed to compute the pointwise log-likelihood. \code{data}
   must be an object that can be indexed as described above
   (\code{data[i,,drop=FALSE]}) to access the data for the \code{i}th
   observation. \code{data} must have a \code{dim} attribute such that
   \code{dim(data)[1]} is equal to \code{N}, the number of observations.
   \item \code{draws}: An object containing the posterior draws for any
   parameters needed to compute the pointwise log-likelihood. \code{draws}
   must have a \code{dim} attribute such that \code{dim(draws)[1]} is equal
   to \code{S}, the size of the posterior sample.
 }
}}

\note{
For models fit to very large datasets we recommend the
  \code{loo.function} method, which is much more memory efficient than the
  array and matrix methods. However, the array and matrix methods are
  typically more convenient, so it is usually worth trying them and then
  switching to \code{loo.function} if memory is an issue.
}
\examples{

### Array and matrix methods (using example objects included with loo package)
# Array method
LLarr <- example_loglik_array()
loo(LLarr)

# Matrix method
LLmat <- example_loglik_matrix()
chain <- rep(1:ncol(LLarr), each = nrow(LLarr))
loo(LLmat, chain_id = chain)

\dontrun{
### Usage with stanfit objects
# see ?extract_log_lik
log_lik1 <- extract_log_lik(stanfit1, merge_chains = FALSE)
loo1 <- loo(log_lik1)
print(loo1, digits = 3)

log_lik2 <- extract_log_lik(stanfit2, merge_chains = FALSE)
(loo2 <- loo(log_lik2))
compare(loo1, loo2)
}

### Using log-likelihood function instead of array or matrix
set.seed(024)

# Simulate data and draw from posterior
N <- 50; K <- 10; S <- 100; a0 <- 3; b0 <- 2
p <- rbeta(1, a0, b0)
y <- rbinom(N, size = K, prob = p)
a <- a0 + sum(y); b <- b0 + N * K - sum(y)
fake_posterior <- as.matrix(rbeta(S, a, b))
dim(fake_posterior) # S x 1
fake_data <- data.frame(y,K)
dim(fake_data) # N x 2

llfun <- function(data_i, draws) {
  # each time called internally within loo the arguments will be equal to:
  # data_i: ith row of fake_data (fake_data[i,, drop=FALSE])
  # draws: entire fake_posterior matrix
  dbinom(data_i$y, size = data_i$K, prob = draws, log = TRUE)
}

# Function method
loo_with_fn <- loo(
  x = llfun,
  chain_id = rep(1, nrow(fake_posterior)), # pretend all draws came from 1 chain for this example
  draws = fake_posterior,
  data = fake_data
)

# Check that we get same answer if using log-likelihood matrix
mat <- sapply(1:N, function(i) {
  llfun(data_i = fake_data[i,, drop=FALSE], draws = fake_posterior)
})
loo_with_mat <- loo(mat, chain_id = rep(1, 100))
all.equal(loo_with_mat, loo_with_fn) # should be TRUE!

}
\references{
Vehtari, A., Gelman, A., and Gabry, J. (2017). Practical
  Bayesian model evaluation using leave-one-out cross-validation and WAIC.
  \emph{Statistics and Computing}. 27(5), 1413--1432.
  doi:10.1007/s11222-016-9696-4.
  (\href{http://link.springer.com/article/10.1007\%2Fs11222-016-9696-4}{published
  version}, \href{http://arxiv.org/abs/1507.04544}{arXiv preprint}).

Vehtari, A., Gelman, A., and Gabry, J. (2016). Pareto smoothed
  importance sampling. arXiv preprint: \url{http://arxiv.org/abs/1507.02646/}
}
\seealso{
\itemize{
 \item \code{\link{psis}} for the underlying Pareto Smoothed Importance
 Sampling (PSIS) procedure used in the LOO-CV approximation.
 \item \link{pareto-k-diagnostic} for convenience functions for looking at
 diagnostics.
 \item \code{\link{compare}} for model comparison.
 \item \code{\link{print.loo}} for info on the \code{print} method.
}
}
