% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/loo.R
\name{loo}
\alias{loo}
\alias{loo.array}
\alias{loo.matrix}
\alias{loo.function}
\title{Leave-one-out cross-validation (LOO)}
\usage{
loo(x, ...)

\method{loo}{array}(x, ...)

\method{loo}{matrix}(x, chain_id, ...)

\method{loo}{function}(x, args, ...)
}
\arguments{
\item{x}{A log-likelihood array, matrix, or function. See the \strong{Methods
(by class)} section below for a detailed description of how to specify the
inputs for each method.}

\item{...}{Optional arguments passed on to \code{\link{psis}}. Possible
  arguments and their defaults are:
\describe{
 \item{\code{wtrunc = 3/4}}{
  For truncating very large weights to \eqn{S}^\code{wtrunc} (set to zero
  for no truncation). We recommend the default value unless there are
  problems.
 }
 \item{\code{cores = getOption("loo.cores", 1)}}{
  The number of cores to use for parallelization. The default for an entire R
  session can be set with \code{options(loo.cores = NUMBER)}. As of \pkg{loo}
  version \code{2.0.0}, \strong{the default is 1 core}, but we recommend
  using as many (or close to as many) cores as possible.
 }
}}

\item{chain_id}{A vector of length \code{NROW(x)} containing MCMC chain
indexes for each each row of \code{x} (if a matrix) or each value in
\code{x} (if a vector). No \code{chain_id} is needed if \code{x} is a 3-D
array. If there are \code{C} chains then valid chain indexes are values
in \code{1:C}.}

\item{args}{Only required if \code{x} is a function. A list containing
the data required to specify the arguments to the function. See the
\strong{Methods (by class)} section below for how \code{args} should be
specified.}
}
\value{
A named list with class \code{c("psis_loo", "loo")} and components:
\describe{
 \item{\code{estimates}}{
  A matrix with two columns (\code{"Estimate"}, \code{"SE"}) and three rows
  (\code{"elpd_loo"}, \code{"p_loo"}, \code{"looic"}). This contains point
  estimates and standard errors of the expected log pointwise predictive
  density (\code{elpd_loo}), the effective number of parameters
  (\code{p_loo}) and the LOO information criterion \code{looic} (which is
  just \code{-2 * elpd_loo}, i.e., converted to deviance scale).
 }
 \item{\code{pointwise}}{
  A matrix with three columns (and number of rows equal to the number of
  observations) containing the pointwise contributions of each of the above
  measures (\code{elpd_loo}, \code{p_loo}, \code{looic}).
 }
 \item{\code{diagnostics}}{
 A named list containing two vectors:
  \itemize{
   \item \code{pareto_k}: Estimates of the shape parameter \eqn{k} of the
   generaelized Pareto fit to the importance ratios for each leave-one-out
   distribution. See the \code{\link{pareto-k-diagnostic}} page for details.
   \item \code{n_eff}: PSIS effective sample size estimates.
  }
 }
}
}
\description{
Efficient approximate leave-one-out cross-validation for Bayesian models. See
\link{loo-package} and Vehtari, Gelman, and Gabry (2016, 2017) for
background.
}
\section{Methods (by class)}{
\itemize{
\item \code{array}: An \eqn{I} by \eqn{C} by \eqn{N} array, where \eqn{I}
is the number of MCMC iterations per chain, \eqn{C} is the number of
chains, and \eqn{N} is the number of data points. For example, the object
returned by \code{\link{extract_log_lik}(stanfit, merge_chains = FALSE)}.

\item \code{matrix}: An \eqn{S} by \eqn{N} matrix, where \eqn{S} is the size
of the posterior sample (with all chains merged) and \eqn{N} is the number
of data points. For example, the object returned by
\code{\link{extract_log_lik}(stanfit, merge_chains = TRUE)}.

\item \code{function}: A function \eqn{f} that takes arguments \code{i},
  \code{data}, and \code{draws} and returns a vector containing the
  log-likelihood for the \code{i}th observation evaluated at each posterior
  draw.

 The \code{args} argument must also be specified and should be a named list
 with the following components:
 \itemize{
   \item \code{draws}: An object containing the posterior draws for any
   parameters needed to compute the pointwise log-likelihood.
   \item \code{data}: An object containing data (e.g. observed outcome and
   predictors) needed to compute the pointwise log-likelihood. \code{data}
   should be in an appropriate form so that \eqn{f}\code{(i=i,
   data=data[i,,drop=FALSE], draws=draws)} returns the \code{S}-vector of
   log-likelihoods for the \code{i}th observation.
   \item \code{N}: The number of observations.
   \item \code{S}: The size of the posterior sample.
 }
}}

\note{
For models fit to very large datasets we recommend the
  \code{loo.function} method, which is much more memory efficient than the
  array and matrix methods. However, the array and matrix methods are
  typically more convenient, so it is usually worth trying them and then
  switching to \code{loo.function} if memory is an issue.
}
\examples{
\dontrun{
### Usage with stanfit objects
# see ?extract_log_lik
log_lik1 <- extract_log_lik(stanfit1, merge_chains = FALSE)
loo1 <- loo(log_lik1)
print(loo1, digits = 3)

log_lik2 <- extract_log_lik(stanfit2, merge_chains = FALSE)
(loo2 <- loo(log_lik2))
compare(loo1, loo2)
}

### Using log-likelihood function instead of matrix
set.seed(024)

# Simulate data and draw from posterior
N <- 50; K <- 10; S <- 100; a0 <- 3; b0 <- 2
p <- rbeta(1, a0, b0)
y <- rbinom(N, size = K, prob = p)
a <- a0 + sum(y); b <- b0 + N * K - sum(y)
draws <- rbeta(S, a, b)
data <- data.frame(y,K)

llfun <- function(i, data, draws) {
  dbinom(data$y, size = data$K, prob = draws, log = TRUE)
}
loo_with_fn <- loo(llfun, args = nlist(data, draws, N, S), cores = 1)

# Check that we get same answer if using log-likelihood matrix
log_lik_mat <- sapply(1:N, function(i) llfun(i, data[i,, drop=FALSE], draws))
loo_with_mat <- loo(log_lik_mat, cores = 1)
all.equal(loo_with_mat, loo_with_fn)

}
\references{
Vehtari, A., Gelman, A., and Gabry, J. (2017). Practical
  Bayesian model evaluation using leave-one-out cross-validation and WAIC.
  \emph{Statistics and Computing}. 27(5), 1413--1432.
  doi:10.1007/s11222-016-9696-4.
  (\href{http://link.springer.com/article/10.1007\%2Fs11222-016-9696-4}{published
  version}, \href{http://arxiv.org/abs/1507.04544}{arXiv preprint}).

Vehtari, A., Gelman, A., and Gabry, J. (2016). Pareto smoothed
  importance sampling. arXiv preprint: \url{http://arxiv.org/abs/1507.02646/}
}
\seealso{
\itemize{
 \item \code{\link{psis}} for the underlying Pareto Smoothed Importance
 Sampling (PSIS) procedure used in the LOO-CV approximation.
 \item \link{pareto-k-diagnostic} for convenience functions for looking at
 diagnostics.
 \item \code{\link{compare}} for model comparison.
 \item \code{\link{print.loo}} for info on the \code{print} method.
}
}
